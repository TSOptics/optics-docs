---
title: .refine()
sidebar_position: 6
---

# .refine(refiner): Optic

```ts
Optic<A>.refine = <B>(refiner: (a: A) => B | false) => Optic<B, partial>;
```

---

This method allows you to _narrow_ the type focused by the original optic.  
It returns a new partial optic focused on the original value in its narrowed type, or **undefined** if the narrowing failed.

The `refiner` function must return the original value in its narrowed type or `false` if it can't be narrowed to this type.

## Examples:

### - On the branch of a discriminated union

```ts twoslash
import { createState } from "@optics/react";
// ---cut---

type Result<T> =
  | { type: "success"; value: T }
  | { type: "failure"; errorMessage: string };

const resultOptic = createState<Result<number>>({ type: "success", value: 42 });

const successOptic = resultOptic.refine((res) => res.type === "success" && res);
//    ^?

successOptic.get(); // { type: 'success', value: 42 }

resultOptic.set({ type: "failure", errorMessage: "Catastrophic meltdown" });

successOptic.get(); // undefined
```

### - On a built-in type

```ts twoslash
import { createState } from "@optics/react";
// ---cut---

const unknownValueOptic = createState<unknown>(42);

const numberOptic = unknownValueOptic.refine((x) => typeof x === "number" && x);
//    ^?
```

### - On a user-defined type with a type-guard

```ts twoslash
import { createState } from "@optics/react";
declare const untypedInitUser: () => any;
// ---cut---

type User = {
  userName: string;
};

function isUser(value: unknown): value is User {
  return typeof (value as User).userName === "string";
}

const stateOptic = createState(untypedInitUser());
//    ^?

const myTypeOptic = stateOptic.refine((value) => isUser(value) && value);
//    ^?
```
