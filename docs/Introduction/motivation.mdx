---
sidebar_position: 1
---

# Motivation

The use of immutable state in web applications has grown in popularity in recent years in a large part due to the fact that immutability helps us track changes in our application’s state, a trait that is used by React (among others) in its rendering strategy.
But the perks of immutability don’t end at UI libraries: it also makes it trivial to implement features based on history, like undo/redo or reset and, overall, immutability makes our code more predictable, composable, testable and easier to reason about when compared to uncontrolled mutability. As a consequence immutability and functional programming in general has never been more popular in the world of JavaScript application development.

However the language wasn’t built around it and the ergonomics of immutability are often significantly worse than using a mutative approach to state.

First updating immutable state is hard, and it gets worse as our state grows over time. We have to make a shallow copy of every level up to the part we want to update. It drowns the signal in noise and makes it easy to introduce accidental mutations in the process, causing particularly hard to track bugs.
Another, possibly more problematic, issue is that composing immutable states together is hard:
In most non trivial applications tree-like structures are not enough and we need to represent our state as a graph, with relations between entities.
But unfortunately we can’t just use references to represent such relations and doing so will only lead to accidental duplication.
What’s often done to alleviate these issues is forcefully flattening and _normalizing_ the state, where relations are represented with ids from other entities.
To consume it we then need to manually _denormalize_ the state, by performing what’s essentially a poor man’s SQL join operation without a query language and without the help of the type system.

The goal for this library is to bridge the ergonomics gap with mutable state while keeping the props of immutability, by bringing a concept from functional programming called Optics, and adapting it to the state management needs of modern TypeScript applications.
An Optic is a reference on a piece of immutable state, allowing you to read and update it but also to decompose it in smaller optics and compose them with other ones referencing different pieces of state.
They solve our previous issues by making it natural to represent complex state graphs and easy to update any deeply nested value, they also help us decoupling our components from our application’s global state.

Optics are syntactically lightweight, performant and type-safe. Just like components they are small composable units that are meant to help your application scale.
