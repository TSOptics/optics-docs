---
sidebar_position: 2
---

import MdxImage from "../../src/components/Image";
import Counter from "../../src/components/getting-started/Counter";
import Counters from "../../src/components/getting-started/Counters";
import CountersWithStep from "../../src/components/getting-started/CountersWithStep";
import CodeBlock from "@theme/CodeBlock";
import Admonition from "@theme/Admonition";

# Getting Started

**Optics** is a library to manage global immutable state in TypeScript applications.

It let's you declare **references** to parts of your state, called **optics**, that allow you to **read** and **update** these parts as well as **subscribe** to their changes.

**@Optics** is lightweight, unopinionated and typesafe.  
The core is framework agnostic and we will eventually ship adapters to other frameworks.

## Requirements

`@optics/react` requires **React 18** or higher and **TypeScript 4.1** or higher.

## Installation

```bash npm2yarn
npm install @optics/react
```

## Basic example

### Creating a state

In our application let's start by creating a state holding a list of users.
For that let's call `createState` and pass it an initial value.

```ts
import { createState } from "@optics/react";

type User = {
  name: string;
  age: number;
  address: {
    city: string;
    street: {
      name: string;
      number: number;
    };
  };
};

const onUsers = createState([
  {
    name: "John",
    age: 42,
    address: { city: "New York", street: { name: "5th Avenue", number: 940 } },
  },
]);
// onUsers: Optic<User[]>
```

`createState` returns an **optic**.  
An optic is a **reference** to a piece of application state and it allows us to read and update this piece.

:::tip
You're not restricted to a single global state, you can call `createState` as many times as want.
:::

### Using optics

- Calling `get` on the optic let's us read the state:

```ts
onUsers.get(); // [{ name: "John", age: 42, address: { ... } }]
```

- Calling `set` on the optic let's us update the state:

```ts
// adds a new user
onUsers.set((prev) => [
  ...prev,
  {
    name: "Jane",
    age: 32,
    address: { city: "Paris", street: { name: "Rue de Rivoli", number: 1 } },
  },
]);

onUsers.get(); // [{ name: "John", age: 42, address: { ... } }, { name: "Jane", age: 32, address: { ... } }]
```

### Deriving new optics

Where it gets interesting is that, from this base optic, you can get new ones focused on different parts of your state !

For exemple let's get an optic that focuses on the city of the first user is our list:

```ts
const onCity = onUsers[0].address.city;
// onCity: Optic<string>
```

:::tip
Deriving a new optic looks just like accessing properties of an object !  
You get the same **type-safety and code completion** in your editor as with plain objects.
:::tip

Now we can directly read and update the city of the first user thanks to our new optic:

```ts
onCity.get(); // "New York"

onCity.set("Boston");

onCity.get(); // "Boston"
```

<details>
  <summary>
    Let's compare that with the manual way of updating immutable data:
  </summary>
  <CodeBlock language="ts">
    {`
// ðŸ˜µâ€ðŸ’«
onUsers.set((prev) => [
  {
    ...prev[0],
    address: {
      ...prev[0].address,
      city: "Boston",
    },
  },
  ...prev.slice(1),
]);
`}

  </CodeBlock>
<Admonition type="tip">
Using optics saves us from quite the boilerplate when updating deeply nested data !
</Admonition>
</details>

Optics allows you to focus on **narrower parts of your state**, allowing you to read and update these parts independently of the rest.

More examples:

```ts
onUsers[0].address.city.get(); // "New York"

const onJaneStreet = onUsers[1].address.street;
// onJaneStreet: Optic<{ name: string; number: number; }>

onJaneStreet.number.set(42);

onJaneStreet.get(); // { name: "Rue de Rivoli", number: 42 }
```

### Usage in components

Your React components can subscribe to an optic and re-render when the focused state changes.

Pass an optic to the `useOptic` hook, just like React's `useState` it will return a tuple with the current value and a setter.

```tsx title=StreetForm.tsx
import { useOptic } from "@optics/react";

const StreetForm = () => {
  const [street, setStreet] = useOptic(onJaneStreet);

  return (
    <div>
      Street
      <label>
        number:
        <input
          value={street.number}
          type="number"
          onChange={(e) =>
            setStreet((prev) => ({ ...prev, number: e.target.value }))
          }
        />
      </label>
      <label>
        name:
        <input
          value={street.name}
          onChange={(e) =>
            setStreet((prev) => ({ ...prev, name: e.target.value }))
          }
        />
      </label>
    </div>
  );
};
```

<details>
  <summary>
    Alternative <code>onChange</code>:
  </summary>
  <CodeBlock language="tsx">
    {`
onChange={(e) =>
  onJaneStreet.name.set(e.target.value);
}
  `}
  </CodeBlock>
  <Admonition type="tip">
    If you're updating only a subset of the focused data, then instead of using
    the setter let's focus on that subset and call <code>set</code> on it !
  </Admonition>
</details>

<br />

The component will re-render when the street changes, whether it is changed from within the component or from another part of the application.

```ts
// outside the component
onJaneStreet.number.set((prev) => prev + 1);
// StreetFrom will re-render
```

However the component will not re-render if an unrelated part of the state changes.

```ts
onJane.age.set((prev) => prev + 1);
// jane's street reference hasn't changed, StreetForm won't re-render
```

### Pass optics in props

Instead of referencing the optic directly, the component could accept one **via its props**.

```tsx title=StreetForm.tsx
import { useOptic, Optic } from "@optics/react";

interface Props {
  onStreet: Optic<{ name: string; number: number }>;
}

const StreetForm = ({ onStreet }: Props) => {
  const [street, setStreet] = useOptic(onStreet);
  // ...
};
```

Now `StreetForm` isn't **coupled** to a specific part of the state anymore, it can take **any optic** focused on a street.

```tsx
// Form for john's streeet
<StreetForm onStreet={onUsers[0].address.street}/>

// Form for jane's street
<StreetForm onStreet={onUsers[1].address.street}/>
```

## Next steps

Now you know the basics and can start to use optics effectively, but that's not all there is to it.  
We suggest you go through the [**core concepts**](./core-concepts) to have a better grasp of the notions introduced here and learn about optic composition.
