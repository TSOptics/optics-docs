"use strict";(self.webpackChunkoptics_docs=self.webpackChunkoptics_docs||[]).push([[7614],{8273:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));n(814);const s={title:"Core Concepts",sidebar_position:3},r="Core Concepts",i={unversionedId:"Introduction/core-concepts",id:"Introduction/core-concepts",title:"Core Concepts",description:"As explained in the previous section it is useful to think of optics as references.",source:"@site/docs/Introduction/core-concepts.mdx",sourceDirName:"Introduction",slug:"/Introduction/core-concepts",permalink:"/optics-docs/docs/Introduction/core-concepts",draft:!1,editUrl:"https://github.com/TSOptics/optics-docs/edit/master/docs/Introduction/core-concepts.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Core Concepts",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/optics-docs/docs/Introduction/getting-started"},next:{title:"Total/Partial",permalink:"/optics-docs/docs/Guides/total_partial"}},l={},p=[{value:"Decompose",id:"decompose",level:2},{value:"Methods",id:"methods",level:4},{value:"Compose",id:"compose",level:2},{value:"State graph",id:"state-graph",level:4},{value:"Decouple",id:"decouple",level:2},{value:"Roots and leaves",id:"roots-and-leaves",level:4},{value:"Conclusion",id:"conclusion",level:2}],u={toc:p},c="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"core-concepts"},"Core Concepts"),(0,o.kt)("p",null,"As explained in the previous section it is useful to think of optics as references.",(0,o.kt)("br",{parentName:"p"}),"\n","In fact in Haskell, where the concept originated, they are often called ",(0,o.kt)("strong",{parentName:"p"},"functional references"),".\nThey point to parts of your application's immutable state and let's you interact with it.",(0,o.kt)("br",{parentName:"p"}),"\n","This parallel is useful to grasp the core concepts of optics because just like references:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"they can be ",(0,o.kt)("strong",{parentName:"li"},"broken down")," into smaller parts by calling properties of the object they point to."),(0,o.kt)("li",{parentName:"ul"},"they can reference other optics and, in doing so, represent ",(0,o.kt)("strong",{parentName:"li"},"relations")," between your different states."),(0,o.kt)("li",{parentName:"ul"},"they can be passed around in your application, to your functions and components.")),(0,o.kt)("h2",{id:"decompose"},"Decompose"),(0,o.kt)("p",null,"We already saw that we can decompose, or break down, an optic into smaller parts by calling properties of the object they point to."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const onJeanneAge = onUsers[1].age;\n// onJeanneAge: Optic<number>\n")),(0,o.kt)("p",null,"When we access the index ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," of the root optic and then the ",(0,o.kt)("inlineCode",{parentName:"p"},"age")," property, getting us a new optic focused on a narrower part of the initial state.",(0,o.kt)("br",{parentName:"p"}),"\n","It's what we call ",(0,o.kt)("strong",{parentName:"p"},"top-down")," decomposition, we start at the top from a root optic at and we break it down into its sub-parts as we go down the tree."),(0,o.kt)("p",null,"Now we can read and update this number ",(0,o.kt)("strong",{parentName:"p"},"independently of the surrounding state"),".\nIn fact we don't have to care if there's a surrounding state at all or if it's an optic direclty returned by ",(0,o.kt)("inlineCode",{parentName:"p"},"createState"),", only what's currently focused matters."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"When deriving an optic in a component body it's better to wrap with in ",(0,o.kt)("inlineCode",{parentName:"p"},"useMemo")," to avoid recreating a new reference at every render."),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const onJeanneAge = useMemo(() => onUsers[1].age, [onUsers]);\n"))),(0,o.kt)("p",null,"It also greatly simplifies immutable updates:\ninstead of having to shallow copy every level up to the one that interests us (the dreaded ",(0,o.kt)("em",{parentName:"p"},"spread operator pyramid of doom"),")\nwe just have to ",(0,o.kt)("strong",{parentName:"p"},"focus on the specific part")," we want to update and call ",(0,o.kt)("inlineCode",{parentName:"p"},"set")," on it."),(0,o.kt)("p",null,"Once we update the underlying value, the subscribers (usually components) will be notified, whether they subscribed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"onJeanneAge")," optic or any other optic whose value would have changed due to the update."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'onUsers.subscribe(() => console.log("users informations were updated")); // \u2705\nonUsers[0].subscribe(() => console.log("John\'s informations were updated")); // \u274c\nonUsers[1].subscribe(() => console.log("Jeanne\'s informations were updated")); // \u2705\nonJeanneAge.subscribe((age) =>\n  console.log(`Jeanne\'s age was updated to ${age}`)\n); // \u2705\n\nonJeanneAge.set(33);\n')),(0,o.kt)("p",null,"Console output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"- users informations were updated\n- Jeanne's informations were updated\n- Jeanne's age was updated to 33\n")),(0,o.kt)("p",null,"John's subscriber was not notified because the former doesn't know about Jeanne or her age."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Don't use destructuring to derive new optics, since we use Proxies under the hood to return new optics from properties the following won't work:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const { age, name } = onJeanne;\n"))),(0,o.kt)("h4",{id:"methods"},"Methods"),(0,o.kt)("p",null,"Calling a property is not the only way to decompose an optic, just like references you can call methods on them.\nIt's a way to derive new optics not from a property but from a condition, a transformation, ..."),(0,o.kt)("p",null,"For example if we want to focus on the oldest user:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const onOldestUser = onUsers.max((user) => user.age);\n// onOldestUser: Optic<User>\n\nonOldestUser.get(); // { name: "John", age: 42, address: { ... } }\n\nonJeanneAge.set(80);\n\nonOldestUser.get(); // { name: "Jeanne", age: 80, address: { ... } }\n')),(0,o.kt)("p",null,"Here ",(0,o.kt)("inlineCode",{parentName:"p"},"onOldestUser")," will always point to the oldest user, so when we age poor Jeanne by 47 years, she becomes the oldest user and the optic points to her now."),(0,o.kt)("p",null,"While ",(0,o.kt)("inlineCode",{parentName:"p"},"max")," is only available when the focused type is an array, some methods are available to every optic."),(0,o.kt)("p",null,"One such method is ",(0,o.kt)("a",{parentName:"p",href:"../API/Methods/convert()"},(0,o.kt)("inlineCode",{parentName:"a"},"convert")),". It let's you perform a lossless conversion from the focused type to another.",(0,o.kt)("br",{parentName:"p"}),"\n","For example if we wanted to manipulate the user's street as a tuple instead of an object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const onJeanStreetTuple = onJeanne.address.street.convert(\n  ({ name, number }) => [name, number] as const,\n  ([name, number]) => ({ name, number })\n);\n// onJeanStreetTuple: Optic<[string, number]>\n")),(0,o.kt)("p",null,"Here we passed two functions to ",(0,o.kt)("inlineCode",{parentName:"p"},"convert"),": one to transform the street object into a tuple, and a second one that does the reverse transformation (from tuple to object).",(0,o.kt)("br",{parentName:"p"}),"\n","Now we can manipulate the street as a tuple even though it is still represented as an object in the state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'onJeanStreetTuple.set(([name, number]) => [name, number + 10]);\n\nonJaneStreetTuple.get(); // ["Rue de Rivoli", 11]\n\nonJeanne.address.street.get(); // { name: "Rue de Rivoli", number: 11 }\n')),(0,o.kt)("p",null,"You can check all the methods available to optics like ",(0,o.kt)("a",{parentName:"p",href:"../API/Methods/min()"},(0,o.kt)("inlineCode",{parentName:"a"},"min")),", ",(0,o.kt)("a",{parentName:"p",href:"../API/Methods/max()"},(0,o.kt)("inlineCode",{parentName:"a"},"max")),", ",(0,o.kt)("a",{parentName:"p",href:"../API/Methods/refine()"},(0,o.kt)("inlineCode",{parentName:"a"},"refine"))," or ",(0,o.kt)("a",{parentName:"p",href:"../API/Methods/convert()"},(0,o.kt)("inlineCode",{parentName:"a"},"convert"))," under the API section of this site."),(0,o.kt)("h2",{id:"compose"},"Compose"),(0,o.kt)("p",null,"We just saw that we can decompose optics (top-down) but we actually can also do the opposite,\nmeaning we can create new optics by composing already existing optics together (",(0,o.kt)("strong",{parentName:"p"},"bottom-up composition"),")."),(0,o.kt)("p",null,"To illustrate let's create a new state, a club with a name and a list of members:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const onClub42 = createState({\n  name: "Club 42",\n  established: "1974",\n  members: [onJeanne, onJohn],\n});\n')),(0,o.kt)("p",null,"As you can see the members we passed are not actual javascript objects but optics we created earlier."),(0,o.kt)("p",null,"When we call ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," on the club's optic it automatically ",(0,o.kt)("strong",{parentName:"p"},"denormalizes")," the result and replaces the optics by their respective state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// onClub42.get() output\n{\n  name: "Club 42",\n  established: "1974",\n  members: [\n    { name: "Jeanne", age: 80, address: { ... } },\n    { name: "John", age: 42, address: { ... } },\n  ],\n}\n')),(0,o.kt)("p",null,"We have created a new state which is the composition of its own state and references to those of our two previous users."),(0,o.kt)("p",null,"If we update the state of one of the members then it's like if the club state was updated as well\nso its subscribers will be notified (will re-render if they are components)."),(0,o.kt)("p",null,"To illustrate let's give back Jeanne her youth:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"onClub42.members.subscribe((members) =>\n  console.log(`one of the ${members.length} members was updated`)\n);\n\nonJeanneAge.set(32);\n")),(0,o.kt)("p",null,"Console output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"one of the 2 members was updated\n")),(0,o.kt)("p",null,"Using optics in the state of an entity is a way to create ",(0,o.kt)("strong",{parentName:"p"},"relations")," between your different states.",(0,o.kt)("br",{parentName:"p"}),"\n","In a relational database we use foreign keys to represent relations between tables, here optics are used for the same purpose.\nIn SQL we use ",(0,o.kt)("strong",{parentName:"p"},"joins")," to get the final denormalized result, with optics it is done automatically."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Opt-out of denormalization"),"You can choose to get the normalized result instead, by setting the denormalize option to ",(0,o.kt)("code",null,"false")," when calling ",(0,o.kt)("code",null,"get"),":",(0,o.kt)("br",null),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"onClub42.get({ denormalize: false });\n")),(0,o.kt)("p",null,"The returned type will of course change depending on whether denormalize is set to\ntrue or false:"),(0,o.kt)("table",null,(0,o.kt)("thead",null,(0,o.kt)("tr",null,(0,o.kt)("th",{width:"500px"},"denormalize: true (default)"),(0,o.kt)("th",{width:"500px"},"denormalize: false"))),(0,o.kt)("tr",null,(0,o.kt)("td",null,(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"{4}","{4}":!0},"{\n  name: string;\n  established: string;\n  members: User[];\n}\n"))),(0,o.kt)("td",null,(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json",metastring:"{4}","{4}":!0},"{\n  name: string;\n  established: string;\n  members: Optic<User>[];\n}\n")))))),(0,o.kt)("h4",{id:"state-graph"},"State graph"),(0,o.kt)("p",null,"The club has a reference to its members but in turn indivual members can also have references to other entities.",(0,o.kt)("br",{parentName:"p"}),"\n","First let's make cities a first-class citizen in our state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const onParis = createState({ name: "Paris", inhabitants: 2_200_000 });\nconst onMilan = createState({ name: "Milan", inhabitants: 1_400_000 });\nconst onNewYork = createState({ name: "New York", inhabitants: 8_500_000 });\n')),(0,o.kt)("p",null,"Then we can rework our initial state. Instead of representing a user's city with a string let's use an optic to reference a previously created city:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'const onUsers = createState([\n  {\n    name: "John",\n    age: 42,\n    address: { city: onNewYork },\n  },\n  {\n    name: "Jeanne",\n    age: 32,\n    address: { city: onParis },\n  },\n]);\n')),(0,o.kt)("p",null,"Now the fully denormalized result from ",(0,o.kt)("inlineCode",{parentName:"p"},"onClub42")," looks like that:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// onClub42.get()\n{\n  name: "Club 42",\n  established: "1974",\n  members: [\n    {\n      name: "John",\n      age: 42,\n      address: {\n        city: {\n          name: "New York",\n          inhabitants: 8_500_000,\n        },\n      },\n    },\n    {\n      name: "Jeanne",\n      age: 32,\n      address: {\n        city: {\n          name: "Milan",\n          inhabitants: 1_400_000,\n        },\n      },\n    },\n  ],\n}\n')),(0,o.kt)("p",null,"As you can see denormalization is recursive, meaning that if a referenced entity has references of its own, they will be denormalized as well."),(0,o.kt)("p",null,"You can update a relation by simply replacing the optic with another one.",(0,o.kt)("br",{parentName:"p"}),"\n","For example if Jeanne moves to Milan:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"onUsers[1].address.city.set(onMilan);\n")),(0,o.kt)("p",null,"Referencing other entities with optics allows us to represent our state as a ",(0,o.kt)("strong",{parentName:"p"},"graph"),",\nwhere the ",(0,o.kt)("strong",{parentName:"p"},"nodes")," are the entities we build with ",(0,o.kt)("inlineCode",{parentName:"p"},"createState")," and the ",(0,o.kt)("strong",{parentName:"p"},"edges")," are the optics relating them together."),(0,o.kt)("p",null,"While immutable state is great it however makes it hard to represent such graphs.",(0,o.kt)("br",{parentName:"p"}),"\n","We usually have to resort to representing the relation with the the id of the target entity and then essentially joining the entities manually to get our denormalized result.",(0,o.kt)("br",{parentName:"p"}),"\n","Optics makes the whole process ",(0,o.kt)("strong",{parentName:"p"},"automatic"),", ",(0,o.kt)("strong",{parentName:"p"},"reactive")," and ",(0,o.kt)("strong",{parentName:"p"},"typesafe"),", which is fundamental for applications that actually need client side state management,\nas most of them will eventually need to represent relations between entities."),(0,o.kt)("admonition",{title:"cycles",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"We need our graph to be ",(0,o.kt)("strong",{parentName:"p"},"acyclic")," to avoid infinite loops when denormalizing.",(0,o.kt)("br",{parentName:"p"}),"\n","That means you can't have both the user referencing the city and the city referencing the user, one of them must exclusively ",(0,o.kt)("strong",{parentName:"p"},"own")," the relation. ",(0,o.kt)("sub",null,(0,o.kt)("sup",null,(0,o.kt)("i",null,"(I guess my ex was just mindful of graph cycles)")))),(0,o.kt)("p",{parentName:"admonition"},"In general it's better to abstain from making the graph overly complex as it can make it easy to accidently introduce cycles,\nas well as making denormalization slow (just like too many joins in SQL can degrade performance).")),(0,o.kt)("h2",{id:"decouple"},"Decouple"),(0,o.kt)("p",null,"Another pattern that optics encourages is ",(0,o.kt)("strong",{parentName:"p"},"decoupling")," your global state from your components."),(0,o.kt)("p",null,"It can be hard to do when dealing with external state because you might be inclined to import it directly in your components."),(0,o.kt)("p",null,"To illustrate let's use a fictitious ",(0,o.kt)("inlineCode",{parentName:"p"},"useStore")," hook implementing the commonly used pattern of selecting a part of the store from the root and subscribing to it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { useStore } from "./myStore";\n\nconst User = () => {\n  const user = useStore((state) => state.users[0]);\n};\n')),(0,o.kt)("p",null,"Here, as noted by the import of the store at line 1, we ",(0,o.kt)("strong",{parentName:"p"},"coupled")," our component to the store.",(0,o.kt)("br",{parentName:"p"}),"\n","The ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," component will get the user from the same store, using the same path every time.\nWe can't ",(0,o.kt)("strong",{parentName:"p"},"reuse the component")," to render any another user."),(0,o.kt)("p",null,"Coupling hurts reusability but also ",(0,o.kt)("strong",{parentName:"p"},"testability"),": we can't easily render the component in isolation (inside a Storybook, a unit test, ...)\nsince we need to carry with us the surrounding context that the selector needs to get the data."),(0,o.kt)("p",null,"And that's where lies the problem, ",(0,o.kt)("strong",{parentName:"p"},"the component shouldn't have know the shape of the global state"),".",(0,o.kt)("br",{parentName:"p"}),"\n","It's only job should be rendering a user, no matter where it comes from."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"While we could split our component into ",(0,o.kt)("em",{parentName:"p"},"smart")," and ",(0,o.kt)("em",{parentName:"p"},"dumb")," ones (or ",(0,o.kt)("em",{parentName:"p"},"container")," and ",(0,o.kt)("em",{parentName:"p"},"presentational"),") to keep the dumb component decoupled from the state,\nthis pattern has fallen out of favour since the introduction of hooks due its verbosity, and the additional nesting it piles up in the component tree.")),(0,o.kt)("p",null,"That's where optics come in, as they allow us to naturally decouple our components from the global state simply by passing them to the component's props:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"interface UserProps {\n  onUser: Optic<User>;\n}\n\nconst User = ({ onUser }: UserProps) => {\n  const [user, setUser] = useOptic(onUser);\n};\n")),(0,o.kt)("p",null,"Now the User component can be passed ",(0,o.kt)("strong",{parentName:"p"},"any optic")," focused on a user, allowing you to ",(0,o.kt)("strong",{parentName:"p"},"reuse it")," anywhere in your application."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<User onUser={onJeanne} />\n<User onUser={onJohn} />\n")),(0,o.kt)("p",null,"When testing you can create a new throwaway user just for your test needs, without having to worry about the rest of the global state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { render } from "@testing-library/*";\n\ntest("User renders a user", () => {\n  const onTestUser = createState({ name: "Vincent", age: 29, address: { ... } });\n\n  render(<User onUser={onTestUser} />);\n});\n')),(0,o.kt)("p",null,"Listing dependencies in the props is always recommanded to avoid coupling and there's no reason that it should be otherwise for global state !"),(0,o.kt)("h4",{id:"roots-and-leaves"},"Roots and leaves"),(0,o.kt)("p",null,"Of course not all components can get their optics through their props as we have to start somewhere with some initial optics.\nThus components close to the root usually import optics directly:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"{1}","{1}":!0},'import { onUsers } from "./users";\n\nconst UserList = () => {\n  const [users, setUsers] = useOptic(onUsers);\n\n  return (\n    <ul>\n      {users.map((user, index) => (\n        <li key={user.id}>\n          <User onUser={onUsers[index]} />\n        </li>\n      ))}\n    </ul>\n  );\n};\n')),(0,o.kt)("p",null,"But now that we have the optic imported we can derive new ones from it and pass them down to the ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," elements.",(0,o.kt)("br",{parentName:"p"}),"\n","In turn we can imagine that the ",(0,o.kt)("inlineCode",{parentName:"p"},"User")," component derives an optic focused on the user's street and pass it down to a ",(0,o.kt)("inlineCode",{parentName:"p"},"StreetForm")," element, etc ..."),(0,o.kt)("p",null,"That way ",(0,o.kt)("strong",{parentName:"p"},"most leaf components can be decoupled")," from the global state, which is convenient as they are the ones that usually need to be reused, tested or documented in stories."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Now that you've learned how to ",(0,o.kt)("strong",{parentName:"p"},"decompose"),", ",(0,o.kt)("strong",{parentName:"p"},"compose")," your state, and ",(0,o.kt)("strong",{parentName:"p"},"decouple")," your components from it,\nyou know every important concept there is to know about state management with optics."),(0,o.kt)("p",null,"To further your knowledge you can look through the following guides:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"../Guides/total_partial"},"Total vs partial"),": understand how a total optic will always yield a value while it might not be the case for a partial one."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"../Guides/map_reduce"},"map/reduce"),": learn how to focus multiple values at a time, and then how to ",(0,o.kt)("strong",{parentName:"li"},"reduce")," the focus back to a single value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"../Guides/forms"},"Forms"),": learn how to build performant and scalable forms by controlling your inputs with optics.")))}m.isMDXComponent=!0}}]);